# ООП Лаба - 2
## М8О-211БВ-24 Николич Савва Радомирович Вариант 7

Требования к программе:

Используя в качестве образца класс Array (см. ниже), реализовать динамические контейнеры с использованием динамического массива.
- Каждый класс должен быть разделен на интерфейс и реализацию.
- Самостоятельно определить необходимые типы, поля и дополнительные методы.
- Реализовать генерацию исключений в конструкторах и методах при необходимости (использовать
стандартные исключения).
- Реализовать арифметические операции: сложение, вычитание, копирование
- Реализовать операции сравнения: (больше, меньше, равно).
- Арифметические операции с присваиванием должны быть реализованы как методы класса.
- Перегрузку операторов применять не нужно
- Объекты классов должны быть иммутабельными (то есть не меняться после создания), результат методов должен возвращаться как новый экземпляр объекта
```c++
class Array
{
public:
 Array();
 Array(const size_t & n, unsigned char t = 0);
 Array(const std::initializer_list< unsigned char> &t);
 Array(const string &t);
 Array(const Array& other);
 Array(Array&& other) noexcept;
 virtual ~Array() noexcept;
};
```
Вариант 7:

Создать класс Six для работы с беззнаковыми целыми шестиричными числами, используя для представления
числа массив из элементов типа unsigned char, каждый элемент которого является шестиричной цифрой.
Младшая цифра имеет меньший индекс (единицы — в нулевом элементе массива). 

Команды запуска и компиляции:

```bash
cd OOP/lab02

mkdir -p build
cd build

cmake ..

make

# Альтернативная сборка
cmake --build .

# Запуск main
./six_main

# Запуск всех тестов
./test/six_tests
```


## Контрольные вопросы

### Вопрос 1:
**Вопрос:** Почему все методы класса `Six` (кроме конструкторов) объявлены как `const`, и какие преимущества дает такой подход?

**Ответ:** Методы объявлены как `const` для обеспечения иммутабельности(неизменяемости) объектов. После создания объект `Six` никогда не меняет своего состояния.

**Преимущества:**
- Безопасность в многопоточных программах
- Предсказуемое поведение
- Упрощение отладки

```cpp
Six a("123");
Six b("45");
Six c = a.add(b);  // Если add не const, он может изменить a!
// Теперь a может быть равно "212" вместо "123"
// Это привело бы к трудноотлавливаемым ошибкам
```

### Вопрос 2:
**Вопрос:** Почему перемещающий конструктор и оператор присваивания помечены как `noexcept`, и какие оптимизации это позволяет компилятору? Что произойдет, если убрать `noexcept` из этих методов?

**Ответ:** `noexcept` гарантирует компилятору, что метод не бросит исключений, что позволяет проводить агрессивные оптимизации.

**Оптимизации с `noexcept`:**
- Контейнер будет предпочитать перемещение вместо копирования это уменьшает время компиляции и работы программы.
- Компилятор не генерирует код для обработки исключений
- Улучшается инлайнинг методов

```cpp
std::vector<Six> numbers;
numbers.push_back(Six("123")); 
// С noexcept: вызывается перемещающий конструктор
// Без noexcept: вызывается копирующий конструктор
```

### Вопрос 3:
**Вопрос:** В каких ситуациях компилятор выбирает конструктор копирования, а в каких - перемещения? 

**Ответ:** Компилятор выбирает конструктор на основе категории значения передаваемого объекта.

Конструктор копирования (для lvalue):
```cpp
Six a("123");
Six b = a;              // a - lvalue копирование
Six c(a);               // a - lvalue копирование
void func(const Six& s);
func(a);                // a - lvalue копирование
```

Конструктор перемещения (для rvalue):
```cpp
Six d = Six("123");     // Six("123") - rvalue перемещение
Six e = std::move(a);   // std::move(a) - rvalue перемещение
Six f = createSix();    // возвращаемое значение - rvalue перемещение
```

Т.е.lvalue (именованные объекты) это копирование, rvalue (временные объекты) это  перемещение.
```